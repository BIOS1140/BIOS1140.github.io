---
title: "Exercise 1 - Introduction to R"
author: "Even Sletteng Garvang"
output: 
  bookdown::html_document2:
    toc: true
    toc_float: true
    highlight: pygments
    css: "style.css"
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
source("setup.R")
library(tidyverse)
```

```{r html-doc, child="html_doc.Rmd", echo = FALSE}
#include html script
```

::: {.green}
**Important concept**

Green boxes summarizes important concepts from the text.
:::

::: {.blue}
**Additional info**

Blue boxes contain small tips and additional information for those that are interested. What's in these is hopefully useful, but not mandatory. Feel free to skip these if you want.
:::

**Text in bold contains small exercises to do on your own throughout the tutorial. These are for your own understanding only, so you don't need to hand them in.**

# Start using R!

## Install R and Rstudio

## Getting familiar with R and the console

### R as a calculator

In the bottom left you will see a `>` where you can input text. This is called the console, and you can directly interact with R through this. Try inputting a number, or any calculation you can think of, and then press `enter`. For example:

```{r, eval = FALSE}
4
4+3
11-5
5*2
3/2
10^2
```

You will see that if you input a single number, R will return that same number to you. If you input a calculation, R will return the result of that calculation.

You can also use parentheses as you would on a normal scientific calculator:

```{r}
10*3+4
10*(3+4)
```

You have now learned how R can be used as a calculator!

### Text input {#textinput}

If you input text into the console, however, you will get the following:

```{r, error = TRUE}
hello
```

The error message reason for this will be apparent later in this tutorial. To get R to return text, you have to enclose the text in single or double quotes (`"` or `'`) like so:

```{r}
"hello"
'hello'
```

::: {.green}
**Important concept:** To make R interpret what you write as text, you have to enclose it with single or double quotes:

-   `"hello"` or `'hello'` rather than just `hello`
:::

### Comments

If you input a `#`, R will ignore whatever comes after on the same line. This means you can write entire lines of comments, or write comments after your calculations:

```{r, eval = FALSE}
# This entire line is a comment, and that is fine!

6 + 4 # add a meaningful comment on why you're doing this
```

Comment your code liberally, so it becomes easier to understand for any person reading your code. That person is often your future self, and you'd be surprised to learn how unreadable uncommented code can be, even if you wrote it yourself! Fortunately, you will never end up in that situation, since from now on you will be commenting everything you do (because I said so).

### Some additional tips about the console

-   use the up and down arrows to cycle through your previous commands
-   if the `>` in the console turns into a `+`, it means that you probably forgot to close a parenthesis or a quote (try e.g. running `"hello`). You will be unable to do anything while the console is behaving like this. Press the `Esc` button to get your familiar `>` back and continue working.
-   Spaces generally don't mean anything when doing calculations, which means `4+3` is equivalent with `4 + 3`. Use spaces to make your code easier to read.

## Scripts

Doing small operations in the console is all well and good, but once you've done something a bit more complex than adding numbers you will want to save what you did in some way. You could use the up-arrow in the console to recall the things you did (even if you close and reopen RStudio), but imagine if the thing you want to recall was a thousand operations ago. That's a whole lot of button pressing! The most convenient way to store what you have done in R is by writing a script.

A script in R is just a text document containing R code, and the file extension is .R (your script can e.g. be called "myscript.R". In RStudio, you can create a new script either from the menu `File > New File > R script` or by pressing `ctrl`+`shift`+`N` on Windows or `command`+`shift`+`N` on Mac.

Working in a script is almost exactly the same as working in the console: You write a line of code in the script, run it, and the result is shown in the console. The main difference is that you have to press `ctrl`/`command`+`enter` to run code from a script, rather than just `enter`. The other big difference is that you can save your scripts, so you have access to all the code you have previously written. For this reason, you should always work in a script rather than in the console.

**Exercise: Create a new script, and save it with a meaningful name (e.g. "BIOS1140_week01.R" in a folder named BIOS1140). Run the commands you ran in the console earlier, but this time from your script instead. Remember to comment your code with `#` as you go along!**

::: {.green}
Whenever you start a new project, create a script for that project. Save your script in a meaningful location with a meaningful name so it will be easy to find later.
:::

# R essentials

In this part of the tutorial, we will learn the fundamentals of R programming, while investigating the demographics of the Nordic countries. All numbers are the 2020 populations taken from the [International Data Base (IDB)](https://www.census.gov/data-tools/demo/idb/#/table) from the US government.

## Assigning to objects

### Problem: numbers are complicated

Let's start by looking at Norway and Sweden. Say you want to find out what proportion the Norwegian population makes up of the total population of Norway plus Sweden. Conceptually, it looks something like this:

$$\frac{Norwegian\ population}{Norwegian\ population+Swedish\ population}$$

**Exercise: The Norwegian population is 5 465 387 and the Swedish is 10 185 555. Use R to calculate the proportion the Norwegian population makes up of the total population. Do the same for the Swedish population.**

------------------------------------------------------------------------

If you were able to do this, great work! Your solution probably looked something like this[^1]:

[^1]: with the comments, I hope!

<div class="fold s o">
```{r, eval = FALSE}
# Norwegian population
5465387 / (5456387 + 10185555)
# Swedish population
10185555 / (5465387 + 10185555)
```
</div>

However, there are several problems with doing it this way. First of all, 5465387 is a stupidly long number, and the probability of typing it wrong is rather high (I actually mistyped a number in the code above, can you spot the error?). Another problem is that if any of the populations change (e.g. you want to update to 2021 numbers), you would have to update it in **four different places** to make this simple change. Third: for someone looking at your code, how will they know what's happening? These numbers have no meaning without their context.

Now we're finally getting to the first taste of why R is more powerful than a regular calculator: we can give our numbers simple names.

### Solution: assign the complicated numbers to named objects

What if you could write some text instead of our stupidly large numbers? Something like `norway_pop` instead of 5465387? Luckily, you can! You can do the following to give your variables a name:

```{r}
# store the number to an object called norway_pop
norway_pop <- 5465387
# store another number to an object called sweden_pop
sweden_pop <- 10185555
```

This is called assignment, and is done using the arrow `<-`[^2]. You have now created a named object, which is a very powerful tool. Your objects behave exactly like the numbers that are stored in them (try e.g. `norway_pop*2` or `sweden_pop+4445`). This means that we can now simply write:

[^2]: You can also use `=` instead of `<-` . If you know another programming language already, like Python, this may feel more natural. I like to use the arrow to remind my muscle memory that I'm working in R, but it makes absolutely no difference which you use, so use whichever you like!

```{r}
norway_pop / (norway_pop + sweden_pop)
sweden_pop / (norway_pop + sweden_pop)
```

Notice how similar this is to the conceptual version we saw earlier! This is much simpler, easier to read and way less error-prone than writing out the numbers each time. In addition, if you want to change any of the population sizes, you will just have to change it in one place instead of four.

To make things even easier, we could store `norway_pop + sweden_pop` as `total_pop`, and also store our results with a name as well:

```{r}
# make total population object
total_pop <- norway_pop + sweden_pop

# make object for Norway's proportion
norway_proportion <- norway_pop / total_pop
# print the result
norway_proportion

# make object for Sweden's population
sweden_proportion <- sweden_pop / total_pop
# print the result
sweden_proportion
```

::: {.blue}
**Additional info**\
If you have experience with Python, you would have printed the objects using `print(norway_proportion)`. In R we don't have to explicitly use `print()`. An object (or any calculation for that matter) is automatically printed when we run it. R does have a `print()` function, though, that can be used if you want to be explicit about printing something.
:::

### Notes about naming variables

You should always give your variables sensible names. In the code above, we could have saved ourselves some typing by e.g. calling the populations `x` and `y` respectively. However, this quickly becomes a nightmare to read when scripts get long, so even though `norway_pop` takes longer to write than `x`, you should go with `norway_pop` so it's possible to understand what's going on in your script.

You can name your variables just about anything, but there are some characters you can't use in their names. Notably, spaces, dashes and a lot of special characters cant' be used, and the name cannot start with a number. If you stick to letters, underscores and numbers (except in the beginning), you should be fine!

Another thing to note about variable names is that they are case sensitive, for instance meaning that `A` can contain something completely different than `a`. In the code above, we used all-lowercase variable names, so what happens if we try to run the object `Norway_pop`[^3]?

[^3]: As a side note, whenever you wonder "what happens if I do ...", try it! The worst thing that can happen if you try something is that you get an error, the best thing is that you learn something useful.

```{r, error = TRUE}
Norway_pop
```

R can't find `Norway_pop`, because it doesn't exist, only `norway_pop` does. Beware of this, as it's often a source of annoying bugs in the code.

::: {.green}
Assign any and all variables to named objects. It's easier to read, and you're less likely to make mistakes. Use good variable names, and beware of case sensitivity!
:::

## Vectors

Let's expand our little Norway-Sweden project to all the Nordic countries. Table \@ref(tab:nordpop) shows the populations of all the Nordic countries.

```{r nordpop, echo = FALSE}
nordic_tab <- read.csv("nordic_data.csv")

knitr::kable(nordic_tab[order(nordic_tab$Country.Area.Name),c("Country.Area.Name", "Population")], col.names = c("Country", "Population"), row.names = FALSE,
             caption = "Population sizes of the nordic countries.")

```

**Exercise: Do the same with all the Nordic countries that you did with Norway and Sweden. Assign each population size to an object and calculate their proportion of the total Nordic population**

------------------------------------------------------------------------

### Problem: too many objects gets complicated {#manyobjects}

If you solved the exercise above, you're probably tired from writing almost the same thing over and over. My solution looks something like this:

<div class="fold s">
```{r, results = "hide"}
denmark_pop <- 5868927
finland_pop <- 5572355
iceland_pop <- 350773
nordic_total <-  norway_pop + sweden_pop + denmark_pop + finland_pop + iceland_pop

norway_proportion <- norway_pop / nordic_total

sweden_proportion <- sweden_pop / nordic_total

denmark_proportion <- denmark_pop / nordic_total

finland_proportion <- finland_pop / nordic_total

iceland_proportion <- iceland_pop / nordic_total

norway_proportion
sweden_proportion
denmark_proportion
finland_proportion
iceland_proportion
```

</div>


That is a lot of typing! And remember that this is only for the Nordic countries, imagine doing this for all the countries in the world! Surely there has to be simpler solution? Luckily, there is.

### Solution: Store it in a vector!

R has a data type called vector, which can store multiple values at once. In our case, this means that we can store the populations of all the Nordic countries in one vector. Let's look at some different ways to make a vector. The following lines all create a vector containing the numbers 1 through 10.

```{r, eval=FALSE}
# create a vector with c()
c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

# create a vector with :
1:10

# create a vector with seq()
seq(from = 1, to = 10, by = 1)

```

1.  You can create a vector manually with `c()`. All your numbers (or other values) go inside the parentheses, separated by comma.
2.  You can create a vector with the colon operator `:`. This creates a vector containing all the numbers starting from the number before `:`, and up to and including the number after.
3.  You can create a vector with `seq()`. The numbers go inside the parentheses, separated by comma. The number after `from =` is the beginning of the vector, after `to =` is the end of the vector, and after `by =` is the distance between the values in the vector.

As a side note, `c()` and `seq()` are what we call functions. We'll get back to functions shortly, so don't worry if you don't fully understand how these work yet. For now, just recognize that any pattern that consists of text and parentheses, `text()`, is a function. The text outside of the parentheses is the name of the function, and anything inside the parentheses is data the function uses.

Like numbers, vectors can be assigned to objects. This works in exactly the same way, using the arrow `<-`.

```{r}
arbitrary_numbers <- c(56, 789, 109, 76)
arbitrary_numbers

my_sequence <- seq(from = 0, to = 60, by = 5)
my_sequence
```

**Exercise: Store the population sizes of the Nordic countries in a vector using `c()`. Input the numbers in alphabetical order of the countries (same as in table** \@ref(tab:nordpop) **above) Assign the vector to an object with a good name.**

<div class="fold s">

```{r}
nordic <- c(5868927, 5572355, 350773, 5465387, 10185555)
```

</div>

### Vector properties

#### Mathematical operations

When you have a vector of numbers, you can apply all the same mathematical operations that you can on a single number. The operation is then applied to each element of the vector separately. Try it!

```{r}
# create a vector from 1 to 10
my_vector <- 1:10

# multiply each element by 2
my_vector * 2

# add 5 to each element
my_vector + 5
```

If you have two vectors of equal length, you can do mathematical operations on both, e.g. multiply two vectors. The first element of the first vector is then multiplied with the first element of the second vector, the second element with the second and so on. You can do the same for division, addition, subtraction and any operation you can think of.

```{r}
# create another vector
my_vector2 <- 11:20

# mutliply them together
my_vector * my_vector2

# add them
my_vector + my_vector2
```

If the two vectors aren't of the same length, you will get a warning, but R will still try to perform the operation. The shorter vector will then start over when it runs out of numbers.

```{r}
# multiplying two vectors of unequal length
1:10 * 1:9

# this is what R does:
#1*1
#2*2
#3*3
#4*4
#5*5
#6*6
#7*7
#8*8
#9*9 # here we use the last element of the vector 1:9
#10*1 # here R "recycles" the vector, using the first element of 1:9
```

Don't worry if you don't quite understand what happens when the two vectors are of unequal length. For now, just remember to keep all your vectors the same length, or something unexpected might happen! To check the length of a vector, you can use the `length()` function.

```{r}
length(my_vector)
length(my_vector2)
```


**Exercise: express the Nordic population sizes in millions by dividing all the numbers in the `nordic` vector by 10^6**

<div class="fold s">

```{r, eval = FALSE}
nordic / 10^6
```

</div>

#### Extracting numbers

Having all numbers stored in one place is great, but what if you want to use just one of them? We use square brackets `[]` to access numbers inside vectors. You put the index of the element you want to extract inside the square brackets like this: `my_vector[1]`. This will extract the first element from the vector, `my_vector[2]` will extract the second. On our `nordic` vector, we could for instance do the following:

```{r}
# extract the third element (Iceland) from the nordic vector
nordic[3]
```

We can also select multiple numbers, by inputting a vector inside the square brackets. `nordic[c(3, 5)] will extract the third and the fifth element of our `nordic` vector, and `nordic[1:3]` will extract elements 1 through 3.

**Exercise: extract elements 2 through 4 from the `nordic` vector. Then, extract only the Scandinavian countries, and store them in an object with a good name.**

#### Getting the sum and mean of a vector

You can do a variety of operations on vectors in addition to using the mathemathical operators `+`, `-`, `*` and `/`. Two of the most common operations are calculating the sum and the mean of all the numbers in the vector. With the `sum()` and `mean()` functions.

```{r}
sum(my_vector)
mean(my_vector)
```

Again, we'll go through what functions are and how they work shortly. There's a variety of other functions you can apply to a vector, such as `max()`, `min()` and `median()`. Try them out!



**Exercise: Use what you have learned about vectors to calculate the population proportions of all the Nordic countries in a single operation. Save it to an object with a good name.**


The solution to the exercise shows how powerful working with vectors can be.

<div class="fold s">
```{r}
nordic_prop <- nordic / sum(nordic)
nordic_prop
```

</div>

This is way simpler than what we did back in section \@ref(manyobjects)! Also, imagine if you had a hundred, or even a million values in your vector. The code would still look exactly the same, making calculations with any number of values trivial.

:::{.green}
**Important concept**  
If you have many values that go together, store them together in a vector. You can do a variety of mathematical operations on vectors, but make sure that all vectors have the same length!
:::


## Strings

As mentioned way back in section \@ref(textinput), you have to write `"hello"` rather than `hello` to get the actual text "hello". Now you may have figured out that this is because we have to separate objects from text in some way. Text within quotes in R (and any programming language) is called strings. These can be stored in objects and combined into vectors just like you can with numbers.

```{r}
"Hello, world!"
greeting <- "Hello, world!"
greeting
string_vector <- c("this", "is", "a", "vector", "of", "strings!")
string_vector
```

To combine several strings into one, or even combine numbers and strings, you can use the function `paste()`:

```{r}
paste("These two strings", "become one")

nordic_sum <- sum(nordic)
paste("The total population of the nordic countries is", nordic_sum, "people.")
```

**Exercise: Combine the names of the Nordic countries into a vector. Make sure the names are in the same order as in table \@ref(tab:nordpop).**

<div class="fold s">
```{r}
nordic_names <- c("Denmark", "Finland", "Iceland", "Norway", "Sweden")
```
</div>

One of many uses for strings is to give names to a vector. You can use the `names()` function to see a vectors names.

```{r}
names(nordic)
```

As you can see, we get `NULL` here, which means that the vector elements don't have any names. We can set the names like this:

```{r}
names(nordic) <- nordic_names
nordic

```

Now, when we print our `nordic` vector, we can see which population size belongs to which country! Neat! We can also extract values from our vector based on names rather than just position.

```{r}
nordic["Denmark"] # equivalent to nordic[1]
nordic[c("Finland", "Norway")] # equivalent to nordic[c(2, 4)]
```


**Exercise: Do some calculations on the now named `nordic` vector (e.g. calculate the proportions again). What happens to the names?**

<div class="fold s">
```{r}
nordic / sum(nordic)

# The names carry over to the new vector
```


</div>

## Data frames

There's more to a country than just it's population size. Table \@ref(tab:nord-more) shows some additional information about the Nordic countries:

```{r nord-more, echo = FALSE}
nordic_tab %>%
  select(Country.Area.Name, Population, Area..sq.km., Life.Expectancy.at.Birth) %>%
  knitr::kable(
    col.names = c("Country", "Population size", "Area (km^2^)", "Life expectancy"),
    caption = "More information on the nordic countries."
  )
```


What if you want to use some more information about the countries, e.g. the area? One solution is to store the new information in a vector:

```{r}
nordic_area <- c(42434, 303815, 100250, 304282, 410335)
```

However, as the number of variables increase, you can get quite a lot of vectors! Luckily there's a way to keep everything together, in what R calls a data frame.

### Creating a data frame

A data frame is conceptually similar to the table above. You have columns of different variables, and rows of observations of these variables. If you have a number of vectors (of the same length!), you can combine these into a data frame with the function `data.frame()`:^[
You can see here that the names of `nordic` carries over when making the data frame. This results in the names of the countries stored in what seems to be a nameless column. These are the row names, and can be accessed with `row.names(nordic_df)`
]

```{r}
nordic_df <- data.frame(country = nordic_names, population = nordic, area = nordic_area)
nordic_df
```

### Extracting the data within the data frame

You previously learned that you can access data in a vector using square brackets `[]`, and the same goes for data frames. However, we now have two dimensions (rows and columns) instead of just 1. The syntax for extracting from a data frame is `df[row, column]`. For instance, to get the area (column 3) of Finland (row 2), we can run:

```{r}
# extract row 2, column 3
nordic_df[2, 3]
```

You can also use the name of the column instead of the position (remember quotes!).

```{r}
nordic_df[2, "area"]
```

If you leave the row field empty, you will get all rows, and if you leave the column field empty you will get all columns.

```{r}
# Get area of all countries
nordic_df[,"area"]
# Get all the information about Iceland
nordic_df[3,]
# get all rows and columns (useless, but it works!)
nordic_df[,]

```

Another way of getting data from your data frame is with the `$` operator. Writing something like `df$column` returns the entire column as a vector.

```{r}
nordic_df$population
```

This is very useful, as you can do the same operations on these vectors that you can on any vector.

```{r}
nordic_df$population / 10^6
mean(nordic_df$area)
nordic_df$area + nordic_df$population
```

**Exercise: Calculate the population density (population/area) of the Nordic countries using the data frame and the `$` operator.**

<div class="fold s">

```{r}
nordic_df$population / nordic_df$area
```

</div>

### Adding data to the data frame

Adding data to the data frame can also be done with the `$` operator. Instead of referencing an existing column, you can simply write a new name after the `$`, and assign to it as a variable like so: `df$newcolumn <- c(1, 2, 3, 4, 5)`.

```{r, error = TRUE}
nordic_df$is_norway <- c("no", "no", "no", "yes", "no")
nordic_df
```

Now you have added a column named "is_norway" to your data frame, which is kind of useless, but still cool.

**Exercise: For a more useful application of creating a new column, add a population density column to `nordic_df` (using the same calculation as in the previous exercise).**

<div class="fold s">

```{r}
nordic_df$pop_density <- nordic_df$population / nordic_df$area
```

</div>

### Subsetting with logical operators

Sometimes you don't know exactly which rows you want to extract from your data. For example, you may want all countries with an area below 300 000 km^2^, or all countries that aren't Norway. For this, we can use something called logical operators.

#### Introduction to logical operators

The most important logical operators in R are larger than `>`, smaller than `<`, equal to `==`, equal or larger/smaller `>=`/`<=` and not equal to `!=`. They return `TRUE` if the condition is true, and `FALSE` if the condition is false. In its simplest form, we can write:

```{r}
# is 3 smaller than 4?
3 < 4
# is 3 exactly equal to 3.01?
3 == 3.01
# are these two strings the same?
"Norway" == "norway"
```

The operators also work on vectors. Then, every element of the vector is checked, and we get a vector of `TRUE` and `FALSE`.

```{r}
# which numbers from 1 to 5 are larger than 3?
1:5 > 3
# which countries has a population larger than 5000000?
nordic > 5*10^6
# which countries in our data frame are named "Norway"?
nordic_df$country == "Norway"
```

**Exercise: play around with the logical operators so you get a feel for how they work. Ask questions like: "is sum(3, 4) the same as 3+4?" or "which is larger, 10^6 or 6^10?", and answer them using logical operators.**

#### Subsetting

The logical operators and the square brackets go hand in hand. If you use these operators inside square brackets, R will return all rows that are `TRUE`, and discard all rows that are `FALSE`.

```{r}
# get all countries with an area below 300 000 km^2
nordic_df[nordic_df$area < 300000, ]
# get all countries except Norway
nordic_df[nordic_df$country != "Norway", ] 

```

Two important things to note here is that you have to explicitly write `nordic_df$` inside the square brackets, and that you have to end with a comma to tell R that you're filtering rows (i.e. leave the column space empty). Neither `nordic_df[area < 300000, ]` nor `nordic_df[nordic_df$area < 300000]` will work.

:::{.green}
**Important concept**  
When you have a lot of data that belongs together, typically something you could store in an excel document and show in a table, make it into a data frame. Many things we will be doing later in this course requires that your data is in a data frame, so learn to recognize this type of object.
:::

# Functions {#functions}

So far you have seen a handful of functions being used, like `c()`, `seq()`, `mean()` and `data.frame()` to name some. Functions are always written in the form `sometext()`. The text outside the parentheses is the function name, and whatever is inside the parentheses are called arguments. A function can be seen as a series of operations that are applied to the arguments, or simply as somewhere you put something in, and get something else in return. They can often save you a tremendous amount of time, compare for example manually calculating the mean of a 1000 numbers vs. using the `mean()` function.

If you want to know more about what a function does, you can write `?` and then the function name, for example `?seq`. Then you will get a help page that tells you more about how the function works, and some examples of use in the bottom. Be aware that the help page is written by programmers for programmers, and is often difficult to understand. In the beginning you will often be better off googling what a function does (but the examples are always useful).

Functions mostly have 1 or more arguments (sometimes 0), which go inside of the parentheses separated by comma, conceptually: `func(arg1, arg2, arg3)`. The arguments can either be input in a set order, or you can name them. Consider the following:

```{r}
seq(1, 10, 2) # "from" is argument no. 1, "to" is argument no. 2 etc.
seq(from = 1, to = 10, by = 2)
```

These are exactly the same, but one uses argument order, and the other the argument names. To figure out the order and names of arguments, you have to consult the help pages or the internet. For simple functions like `seq()` and `mean()` it's common to omit the argument names, while for more complicated functions it's better to include them, so you clearly show what you're doing.

Another thing that is useful to know, is that as long as we are inside a parenthesis, we can have line breaks in our code. This means that we can put each argument on a separate line, which makes code more readable. Instead of the code above, we could also have written:

```{r}
seq(from = 1,
    to = 10,
    by = 2)
```

This may not matter much for such a simple function, but it gets way easier to read long, complicated functions if it's formatted this way. You will see this formatting used quite a bit in the section about plotting, where you often have many long arguments.

# Data import {#dataimport}

_This part of the tutorial is a simplified version of [this tutorial of mine](https://evengar.github.io/short-tutorials/data-import.html). If you want to know more about data import in R, check that one out!_

I've frequently had you imagine doing the data input for data from all countries in the world throughout this tutorial. You may already have thought manually inputting data for the entire world like we did with the Nordic countries above is time-consuming and error-prone. This is correct, and we should be able to do something smarter. Luckily, we can download data as a text file and import it into R as a data frame!

## Data formats

Start by downloading the file [worlddata.csv](https://PLACEHOLDER.LINK) and make sure you know where on your computer it's downloaded to (suggestion: the same folder as your R script). Open the file in a plain text editor on your computer (e.g. Notepad on Windows or TextEdit on Mac). You can see that we have one row of variable names, and then one row of data for each country. The values are separated by comma making this what we call _comma separated values (csv)_, which is a very common format to store data in. Data entries can also be separated by e.g. spaces, tabs, semicolon and much more. All of these can be imported into R, but you always need to be aware how your data are formatted.

## Working directories

The next step is to make R look in the same folder that your data is in. An important concept is that **R only works in one folder at a time**. You can get the folder where R is currently looking, called the working directory, by running the command

```{r, eval=FALSE}
getwd()
```

This may or may not be the folder where your text file (and/or R script) is located (probably it isn't). If R is looking in a different folder than you want it to, you need to tell it where to look, this can be done in a variety of ways, the most manual being the function `setwd()`:

```{r, eval = FALSE}
# set the working directory to the BIOS1140 folder within "Documents"
setwd("C:/Documents/BIOS1140")
```

Another way to set the working directory (in RStudio) is by navigating to `Session > Set working directory` and choosing the folder you want. A third way is to find the "Files" tab in RStudio (in the bottom-right pane), navigate to your folder there, and click `More > Set as working directory`.

**Exercise: Download the csv file to your computer (make sure you know where), and set the working directory to the same folder as the file is in.**

:::{.green}
**Important concept:** R only works in one folder at a time, this folder is called the working directory. Get your current working directory with `getwd()` and set a new working directory either with `setwd()` or by navigating in RStudio. To import a file into R it has to be in your current working directory!
:::

## Importing

When importing data, there are three things you need to consider:

1. Does the first row in the data contain variable names? If so, this is called a header.
2. How are the values separated? (e.g. comma, semicolon, tab)
3. What is the decimal marker? It is usually period `.` but can sometimes be comma `,`

**Look at the file `worlddata.csv` and answer the three questions above for that file.**

The function for reading data into R is `read.table()`. The first argument is the file name in quotes. It also has three more arguments^[see section \@ref(functions) if you forgot what an argument is] to answer the three questions above.

1. set `header = TRUE` if the data has a header, `header = FALSE` if it doesn't.
2. `sep =","` for comma separated values, `";"` for semicolon, `"\t"` for tab space, and much more.
3. `dec` is the decimal marker, either `dec = "."` or `dec = ","`

Now you should be able to import the data! I've made some skeleton code for you to fill out below to simplfy things.

**Exercise: import `worlddata.csv` into R by filling in the blanks in the code below.**

```{r, eval = FALSE}
# fill in the blanks (after "=")
world_data <- read.table("worlddata.csv", header = , sep = , dec = )
```

<div class="fold s">

```{r, echo = FALSE}
world_data <- read.table("worlddata.csv", header = TRUE, sep = ",", dec = ".")
```

</div>

If you managed to do this, you now have data for all countries in the world stored in a data frame! Try doing some operations on it to get familiar with the data. Some suggestions (remember that you can write `?functionname` to find out more about a function):

* `head()` shows the first rows of the data frame
* `summary()` gives a summary of key aspects of the data frame
* use the `$` operator to extract columns, add or multiply them toghether, or whatever you want!


# Plotting

_This part of the tutorial is a simplified version of [this tutorial of mine](https://evengar.github.io/short-tutorials/plotting.html). If you want to know more about plotting in R, check that one out!_

R is a powerful tool for visualizing your data. You can make almost any kind of plot, revealing connections that are hard to see from summary statistics. This section is a starting point for learning about plotting in R introducing the most important methods.

The basic function for plotting in R is simply `plot()`. This function will guess what kind of plot to make based on the data you provide. You can supply many arguments to the `plot()` function to get the visualisation you want, which we will gradually go through here.

## Plotting vectors

The simplest way of plotting in R is by plotting two vectors of equal length. One vector gives the x-value, and another gives the y-value.

```{r plvec, caption = "Two vectors plotted against each other."}
# make two vectors of equal length
x <- 1:50
y <- 51:100

plot(x, y)

```

As you can see, it makes a simple plot of our data, using points as the default. If we want to make a line graph we have to specify `type = "l"`:

```{r}
plot(x, y, type = "l")
```

For all the different ´type´ arguments, see the plot-function's help page by running `?plot`.

:::{.blue}
**Tip:** Remember that when you use R's `$` operator to pick out a single column from a data frame, you create a vector. Using this, you can easily plot the columns of your data frame. Another way of doing this is introduced in section \@ref(pltdf).
:::

## Plotting data frames {#pltdf}

The thing you probably will plot most often is data frames, containing your own or someone else's data. For this part we will use the `world_data` object that you imported in section \@ref(dataimport). To get an overview of the data, we first use the `summary()` function.

```{r}
summary(world_data)
```


We could then simply write `plot(world_data)`, which plots all the values against each other:

```{r, fig.cap = "A plot of the entire data set."}
plot(world_data)
```

Even for this relatively small data set this visualisation can be quite overwhelming. While this kind of plotting can be useful to get an overview, we often want to focus on specific relationships between our data. To plot two values against each other you use the following syntax: `plot(y_axis_variable ~ x_axis_variable, data = my_data)`^[the `~`character is called "tilde", if you want to google how to produce it on your keyboard].
If we want to investigate the relationship between fertility and life expectancy in our data, we can write:

```{r, fig.cap = "Life expectancy vs Fertility rate"}
plot(Life_Expectancy_at_Birth ~ Total_Fertility_Rate, data = world_data)
```

We get a nice scatterplot of those data, showing a correlation between these variables. We could use the `type = "l"` argument here as well, but it doesn't necessarily make much sense.

```{r, fig.cap = "This makes no sense!"}
plot(Life_Expectancy_at_Birth ~ Total_Fertility_Rate, data = world_data, type = "l")
```



## Special plot commands (histograms, boxplots, barcharts etc.)

While `plot()` is good for a lot of things, you'll want other things than scatterplots. Then you have to use different functions for making your plot:

* `barplot()` for barplots
* `hist()` for histograms
* `boxplot` for boxplots

We won't go into a lot of detail with these, but below are some examples of their usage:^[the barplot uses the `table()` function. This function takes a vector, and counts how many times a given value occur in our data, in this case the continents. Remember that you always can run `?table` if you want to know more.]

```{r}
# barplot: number of countries per continent
barplot(table(world_data$Continent))

# histogram of fertility rate
hist(world_data$Total_Fertility_Rate)

# boxplot of life expectancy divided by continent
boxplot(Life_Expectancy_at_Birth ~ Continent, data = world_data)
```

Additionally, some functions add elements to an existing plot instead of creating a new one:

* `lines()` add lines on top
* `points()` add points on top

```{r, fig.cap="Plot with added line (red) and added points (blue)"}

plot(x, y, type = "l")
lines(x, y - 5, col = "red")
points(c(0, 10, 15), c(60, 80, 70), col = "blue")

```

## Customizing your plots

The `plot()` (and `lines()` and `points()`) function contains a lot of arguments to customize your plots. Below is a (non-comprehensive) list of parameters and what they do:

* `col` changes the color of the plot
* `pch` changes the shape of your points
* `lty` changes line type
* `main` changes the title
* `xlab` and `ylab` changes the axis labels

Below is an example that uses all these arguments in a single plot, see if you can follow what happens.

```{r}
plot(x, y, 
     type = "l",
     main = "customization options",
     xlab = "x-axis",
     ylab = "y-axis")
lines(x, y - 5, 
      col = "red", 
      lty = 2)
points(c(0, 10, 15), c(60, 80, 70), 
       col = "blue", 
       pch = 10)
```

# Installing and loading packages

So far, all the functions we have used in this tutorial is part of your R installation. However, people all around the world have developed their own custom functions, and shared them in what we call packages. During this course, we will need several of these packages, in this section you will learn how to install them.

Packages in R can be installed with the function `install.packages()`. **You will only have to install a package once per computer**. Here is how to install the `ggplot2` package, which we will use next week:

```{r}
install.packages("ggplot2")
```

When a package have been installed, you have to load it in order to use it. **You have to load a package each time you want to use it in a script.** You load a package using the 
function `library()`:

```{r}
library("ggplot2")
```

Make a habit of loading all the packages you use at the top of your script, that makes it easier to follow.

:::{.green}
**Important concept:**  
Packages contain custom functions that you will need later in this course (and during the rest of your studies and work as a biologist).

* install a package with `install.packages()`
  * you only need to do this once per computer
* load a package with `library()`
  * you need to do this every time you want to use that package. Load all packages you need at the top of your script

:::