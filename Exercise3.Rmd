---
title: "Changes in Allele and Genotype Frequency"
output: 
  bookdown::html_document2:
    toc: true
    toc_float: true
    highlight: pygments
    css: "style.css"
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
source("setup.R")
```

```{r html-doc, child="html_doc.Rmd", echo = FALSE}
#include html script
```

::: {.green}
**Important concept**

Green boxes summarizes important concepts from the text.
:::

::: {.blue}
**Additional info**

Blue boxes contain small tips and additional information for those that are interested. What's in these is hopefully useful, but not mandatory. Feel free to skip these if you want.
:::

**Text in bold contains small exercises to do on your own throughout the tutorial. These are for your own understanding only, so you don't need to hand them in.**

# Introduction

Over the last two tutorials, we learned the basics of R and also how to manipulate, visualize and explore data. From this tutorial onwards, we will start change direction a little and reinforce some of the concepts of evolutionary genetics that you have been learning during the class sessions. This doesn't mean we are going to throw you in at the deep-end and expect you to be completely relaxed in R, we will still take the opportunity to work through some of the concepts of the language we have already touched upon. Again remember, it is perfectly fine to ask for assistance or to look up R code you don't understand - we use R everyday and turn to Google for solutions almost constantly!

For the bulk of this session, we will focus on exploring the Hardy-Weinberg (HW) model and testing for deviations from Hardy-Weinberg Expectation (HWE) using R code. You will recall that the HW-model is basically an idealized model of the relationship between allele and genotype frequencies, in the absence of the action of demographic processes such as inbreeding, and evolutionary processes such as genetic drift or selection. The model therefore acts as null model for testing whether such processes have taken place. In other words, we can compare our real data to the expectation and draw inference on what demographic or evolutionary processes might be acting in the real world. As well as allowing us to flex our R abilities, examining the HW-model also requires us to perform some basic statistical analysis, particularly a goodness of fit test.

In addition to the HW model and testing for deviations from HWE, we will also learn how to simulate genetic drift in R. Here we will make use of the visualisation skills we learned with ggplot2 in Chapter 2 to recreate Figure 3.7 from the textbook. We hope that this will have the dual benefit of letting you play with population parameters in order to understand genetic drift but also to help you develop your R programming skills in more detail.


## What to expect

In this section we will:

-   learn about for-loops in R
-   explore the concept of Hardy Weinberg Equilibrium using R
-   simulate genetic drift under the Hardy Weinberg expectation
-   take a first look at how we can use R to program

The tutorial is divided into two parts:

1.  A section focused on general R programming, where you learn concepts that can be used across many fields and even programming languages.
2.  A section focused on using R for evolutionary biology, where you apply some of the concepts you've learned in this tutorial and earlier to solve problems in evolutionary biology.

In the second section, most of the code is quite straightforward, but you might encounter some more complicated code that you haven't learned enough to understand yet. This will be clearly indicated, and we only expect you to have a general sense of what's going on, not understand what every bit of the code does.

# R programming: for-loops

In this section we will learn about for-loops, which is an important concept for any kind of programming (not just in R!). It is made so you can follow it even if you've never heard of loops in programming before, but should also be useful for those who already have experience with loops in another programming language (like Python) and want to learn how it's done in R.

## Motivation: why loop?

Let's start by making a numeric vector that we want do do some operations on.

```{r}
x <- seq(2, 20, 2)
x
```

Say you want to multiply every element by 5. You've already learned to do that in R:

```{r}
x * 5
```

However, what if we want to add two and two elements of the vector together? With our vector `x`, this would be `2+4`, `4+6`, `6+8` and so on. There is no simple way to do this that you've learned yet. We could use the square brackets to extract individual elements and do 9 calculations like this:

```{r, eval = FALSE}
x[1] + x[2]
x[2] + x[3]
x[3] + x[4]
x[4] + x[5]
x[5] + x[6]
x[6] + x[7]
x[7] + x[8]
x[8] + x[9]
x[9] + x[10]
```

But this is a lot of typing for doing a repetitive task, which we want to avoid[^1]. What if we could generalize this, so the computer does the repeated operations for us instead? That's where for-loops come in.

[^1]: because it's bothersome and there's a great chance of making errors, and imagine how long it would take if our vector had 1000 or 10000 elements!

## How a for-loop works

Before we go into solving our example, we have to learn a bit about for-loops. A for-loop in R conceptually looks like this:

```{r, eval = FALSE}
for (variable in vector){ # variable starts as the first element of vector
  
  # do something involving variable
  
} # when the curly bracket ends, variable becomes the next element of vector
```

When the loop starts, `variable` is set to the first element of `vector`. Within the curly braces ("krølleparentes") some operation is done using this `variable`. Then, after the closing curly bracket, `variable` becomes the next element in `vector`, and whatever is inside the curly braces gets repeated with this updated `variable`. This goes on until you've been through all elements of `vector`. Since it repeats an operation for all the elements of `vector`, we say that it "loops over" `vector`.

This might be easier to understand if you see a real example of a for loop[^2]:

[^2]:

    Note that you explicitly have to use `print()` inside a for-loop, unlike what you've done so far. Something like

    ```{r, eval = FALSE}
    for (element in 1:10){
    element
    }
    ```
    won't actually print anything.


```{r}
for (element in 1:10){
  print(element)
}
```

Here you can see more of what's actually happening. In the first round, `element` is the first element of `1:10`, i.e. 1, which is printed. Then, `element` becomes the second element of `1:10`, which is 2, and `print()` prints it. This goes on until you have looped over the entire vector, and the loop ends after printing 10. Below is what actually happens for each round of the loop.

<div class="fold c">

```{r, eval = FALSE}
print(1) # round 1, element is 1
print(2) # round 2, element is 2
print(3) # round 3, element is 3
print(4) # ... and so on
print(5)
print(6)
print(7)
print(8)
print(9)
print(10)
```

</div>

Notice how many lines you saved by writing a loop! The power here comes from that it doesn't matter how long your vector is, and you can do any operation on the elements of the vector. Say we want to multiply each element of our vector `x` with 5, which we did in the start of this tutorial.

```{r}
for(element in x){
  print(element * 5)
}
```

You can also use this with other kinds of vectors, e.g. a vector of strings.

```{r}
animals <- c("cat", "dog", "horse", "badger", "unicorn")

for (animal in animals){
  print(animal)
}
```

:::{.green}
**Important concept:**  
Use a for-loop to do the same operation over and over on the elements of your vector. The basic structure of a for-loop looks like this:

```{r, eval = FALSE}
for (variable in vector){
  # do something
}
```

:::

:::{.blue}
**Tip:**

You may have noticed that I've called the variable that is changing for each iteration different things in all the examples, namely `variable`, `element` and `animal`. Actually, you can call this variable anything (within reason). All you have to remember is to call it the same thing within the loop as when starting it. In other words, this works^[but it's kind of dumb, don't do it]:

```{r, eval = FALSE}
for (whatever_you_want_to_call_the_variable in 1:10){
  print(whatever_you_want_to_call_the_variable)
}
```

But this doesn't:

```{r, eval = FALSE}
for (some_name in 1:10){
  print(another_name)
}
```

:::

**Exercise: Create a vector containing the names of five countries. Use a for-loop to print the countries. Optional: use the `paste()` function to output "`country` is a country" for each element**

## Indexing with for-loops

To solve our initial problem (and also for the things we will be doing later), we need to introduce one more concept: using the changing variable in your for-loop as an index for your vectors. If we look once more at our `animals` vector above, there are actually two ways of printing every element:

```{r, eval = FALSE}
# printing the element like we did earlier
for (animal in animals){
  print(animal)
}

# printing the element using an index
for (index in 1:5){
  print(animals[index])
}

```

The execution of the latter for-loop looks like this:

```{r, eval=FALSE}
print(animals[1])
print(animals[2])
print(animals[3])
print(animals[4])
print(animals[5])
```

Note that rather than looping over the `animals` vector itself, we loop over a vector from 1 to 5, using those numbers to access the values inside `animals`. Here we made this vector by writing `1:5`, but a better way would be writing `1:length(animals)` so we can be sure that the index vector is the same length as the `animals` vector. Looping this way has the advantage that we can loop over several vectors at the same time:

```{r}
score <- c("good", "great", "fine", "best", "probably not real")

# looping over both animals and score
# note the use of 1:length(animals) instead of 1:5

for (index in 1:length(animals)){
  # paste together the current element in animals and score
  # grading will be overwritten every round of the loop
  grading <- paste(animals[index], "is", score[index])
  print(grading)
}

```

We can also access more than one element of a vector at once, by using e.g. `index - 1` to access the previous element.

```{r}
for (index in 2:length(animals)){ #note: starting on 2
  friends <- paste(animals[index], "and", animals[index - 1], "are friends")
  print(friends)
}
```

Show the code below to see how this would look if done manually.

<div class="fold c">
```{r, eval = FALSE}
# first round, remember that writing animals[2 - 1] is
# exactly the same as writing animals[1]
friends <- paste(animals[2], "and", animals[2 - 1], "are friends")
print(friends)

# second round
friends <- paste(animals[3], "and", animals[3 - 1], "are friends")
print(friends)

# third round
friends <- paste(animals[4], "and", animals[4 - 1], "are friends")
print(friends)

# fourth round
friends <- paste(animals[5], "and", animals[5 - 1], "are friends")
print(friends)
```

</div>

Now we know all we need to solve our initial problem, which we will return to in the next section.

**Exercise: In addition to your country vector from before, make a corresponding vector containing continents. Use indexing with for loops and the `paste` function to print "`country` is in `continent`" for each of the countries and continents in your vector.**

:::{.green}

**Important concept:**  
Use for-loops with indexing when you want to access several elements of one or more vectors at once. This is basically every time, so use indexing in your for-loops every time.

:::

## Solving our problem

To remind you of where we started: we want to add the adjacent elements of our vector `x` together in the smartest way possible.

```{r}
x <- seq(2, 20, 2)
```


Below is how this can be done with for-loops. I encourage you to try to solve it yourself before looking at the solution.

<details><summary>Show hint</summary>

Hint: Loop over the vector `2:length(x)`[^5]. For every round, add `x[index]` and `x[index - 1]` together and print this.

</details>



[^5]: Something to think about: Why do we start the vector we're looping over at 2, not 1? what would happen if we started at 1? (hint: what is `1 - 1`, and does that correspond to an element in our vector?)

<div class="fold s o">

```{r}
for (index in 2:length(x)){
  added <- x[index] + x[index - 1]
  print(added)
}
```

</div>

## Storing values from a for-loop

One final concept before going on to work with evolutionary biology. In the last section, we printed our results. What if we wanted to do work further with the results we got? We could copy the numbers from the console and create a new vector manually, but (like so many of my stupid suggestions throughout these tutorials) this is bothersome and doesn't scale well. The best way to store values from a for loop is to create an empty vector before the loop, and fill in that vector as we loop.

First we use the `rep()` function to create a vector containing zeros. You can read the following `rep(0, 10)` "as repeat 0, 10 times", i.e. you get a vector of 10 zeros.

```{r}
# repeat 0, 10 times
results <- rep(0, 10)

# to ensure that results is the same length as x, we should instead write:
results <- rep(0, length(x))
```

Then, we loop over the same index as before, but instead of printing our result, we store it as an element of our `results` vector.

```{r}
for (index in 2:length(x)){
  results[index] <- x[index] + x[index - 1]
}
```

This doesn't print anything yet, but the results are now stored in the `results` vector.

```{r}
results
```

We see that the first element us still 0, which isn't perfect, but good enough for now!

That concludes this week's R-focused part of the tutorial. Some of the Evolutionary biology-focused part will use the concepts you have learned here, so check back here if there is a part of the code you don't understand.

# Evolutionary biology

## The Hardy-Weinberg model

### Plotting the expected genotype frequencies

(droppe hele avsnittet om "some programming tricks for the HW model)

## Testing for deviations from the Hardy_Weinberg Expectation

### An easier way?

## Simulating genetic drift


### A simple case of genetic drift over a single generation using the binomial distribution

(droppe hele avsnittet om "Writing your own R functions")

### Using a custom function to simulate drift over multiple generations

Introduserer en egenlagd funksjon for å simulere drift, og sier at det er OK om de ikke forstår alt ennå. Bytter ut sapply() med for-loop, så skal det være fullt mulig for dem å skjønne hva som skjer inni funksjonen.

<details><summary>Show code</summary>
Some text

```{r code}
# even code
print("Hello world!")
```


</details>

