[["ch10.html", "Week 10 Advancing Further in R", " Week 10 Advancing Further in R Throughout these tutorials, we have introduced you to evolutionary genetic concepts using R. By now, you should have some familiarity with the versatility of R for data analysis and what is possible with it. We have gone from manipulating vectors and dataframes to processing genome-resequencing data and calculating population genomic statistics. With a course as broad as this, we understand it is difficult to feel like you fully understand every aspect of the analyses you are conducting - there is obviously a lot to learn! Ultimately, it is impossible for you to achieve this within a single course, using R properly takes experience and practice. Indeed, wed argue that there is no real mastery of R, it is a tool with which you are always able to learn new things. We learn all the time in R and we have been using it for quite some time! Nonetheless, there are obviously basics that you can master and that you can build upon in your own work, research and analysis. You are already familiar with many of the most important of these - data structures, how to use functions, how to manipulate and visualise data. How can we go further, to giving you an introduction to some more advanced techniques in R? In this final session, will take a step back from population and evolutionary genetics to focus once more on how R itself works, except this time we will focus mainly on programming. We will return to some R programming topics you have actually already encountered but in more detail, with more of a focus on explaining them piece-by-piece. What to expect In this section we will: learn about some advanced features of RStudio learn about joining data sets learn more about vectorisation, and how to use lapply() and sapply() Getting started As always, we need to set up our R environment. Well load tidyverse as usual and thats the only package we will use today. # clear the R environment rm(list = ls()) # install new packages install.packages(&quot;tidyverse&quot;) # if not already installed # load packages library(tidyverse) "],["advanced-features-of-rstudio.html", "10.1 Advanced features of RStudio", " 10.1 Advanced features of RStudio Back in the introductory session, we learned tht RStudio is a front-end for R. More specifically, RStudio is an integrated development environment that makes it more straightforward to do a lot more than just interact with the console. Much of these features are specifically designed with programming in mind and so we will give a short introduction to them. 10.1.1 Projects, projects, projects One of the most useful features of RStudio is its ability to separate your work into different projects. Throughout the tutorials, you might have amassed a large number of files (i.e. datasets, scripts and so on) with little obvious organisation. You might have also had to set your working directory repeatedly. This can become very tedious when you are working on multiple things at once in R. Instead, you can very easily subdivide your work into different RStudio projects, which are essentially separate working directories. You can make brand new ones or associate them with existing work. You can see here for a more detailed explanation on how to manage projects in RStudio. 10.1.2 Everyone has a history Another useful feature of RStudio (and also the standard R distribution) is the fact that every command, function and input you type to the console is stored as a history. You can access this very easily using the function history. For example: # show recent command history history() In RStudio, this command will actually open the history pane and show you previous commands that you have run. You can even use the buttons at the top of this pane to reread commands into the console (i.e. To Console) or copy them into an R script (To Source). There is also an even easier way for you to quickly access the history or previously run commands when you are in the console. You can simply press the up key on your keyboard to rerun the previous lines. This can save you a lot of time and retyping. 10.1.3 Tab complete and other hotkeys When typing code into a script or the R console, RStudio allows you to do something called tab completion. This simply means if you hit the tab key while typing a function or object name, it will give you a list of options. For example, try typing pl into the R console and then pressing tab. You will see a list of available functions and you can then select the function you want from them. Tab completion also works within a function too. Try using tab complete to call the function plot and then pressing it again inside the brackets. You will see the arguments the function requires and if you hover over them, a small pop-up will give you a brief explanation of what they are. There are actually a large number of keyboard based shortcuts you can make use of with Rstudio - these include useful things like Ctrl + 1 or Ctrl + 2 to switch between the console and script panes. You can see a whole list of them here or by selecting Tools &gt; Keyboard Shortcuts Help from the menu bar at the top of the program. 10.1.4 Code checking A further useful feature for writing R scripts is the fact that the script viewer has a code syntax checker. This checks whether arguments or brackets are missing. For example, try pasting the following into a script and seeing what you get: # Try these to trigger RStudio syntax checking plot(x, ) result &lt;- c(1,2,3)) It might take some time to get used to reading these, but it is very helpful for seeing where errors might have occurred. This is especially useful if you are writing large blocks of code and you want to get some insight into what might be going wrong. Indeed, this is part of RStudios general design as a coding tool - you will have also noticed some of the other features this incorporates by now like syntax highlighting. For example, have a look at the simple for loop code block below, you can clearly see that RStudio highlights different parts of the code. # a simple for loop for (i in 1:10){ print(i) } This simple block contains two control flow examples (for and in) - these are highlighted in in the code block here. There is also a numeric vector - this is shown in a different colour. Everything else, including objects and standard function calls are in black. Syntax highlighting like this makes code easier to read and is highly customisable too. "],["more-on-data-handling-categorising-and-joining.html", "10.2 More on data handling: categorising and joining", " 10.2 More on data handling: categorising and joining Handling large amounts of data with few lines of code is one of Rs strong points. In this section we will show how you can use ifelse() and the left_join() function from dplyr to make categories and add information to your data 10.2.1 ifelse() for making categories Lets first review what the ifelse() function does. As you learned back in chapter 5, ifelse() takes a logical statement, and returns something different depending on whether the condition is TRUE or FALSE: # make a small vector y &lt;- c(20, 30, 50) # use ifelse to evaluate it ifelse(y &gt; 25, &quot;Greater than 25&quot;, &quot;Not greater than 25&quot;) This function can be extremely useful for creating new variables in datasets. Lets return to the familiar starwars data from dplyr in order to use the function in this way. starwars #&gt; # A tibble: 87 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke~ 172 77 blond fair blue 19 male mascu~ #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu~ #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ #&gt; 4 Dart~ 202 136 none white yellow 41.9 male mascu~ #&gt; 5 Leia~ 150 49 brown light brown 19 fema~ femin~ #&gt; 6 Owen~ 178 120 brown, gr~ light blue 52 male mascu~ #&gt; 7 Beru~ 165 75 brown light blue 47 fema~ femin~ #&gt; 8 R5-D4 97 32 &lt;NA&gt; white, red red NA none mascu~ #&gt; 9 Bigg~ 183 84 black light brown 24 male mascu~ #&gt; 10 Obi-~ 182 77 auburn, w~ fair blue-gray 57 male mascu~ #&gt; # ... with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; Now we can take a look at the starwars$species vector. There are a lot of different species, so what if we wanted to create a vector that simply states whether an individual is a droid or not? # if else to identify droids and non-droids ifelse(starwars$species == &quot;Droid&quot;, &quot;Droid&quot;, &quot;Non-Droid&quot;) This can be useful e.g. for comparing droids and non-droids in a plot or table. Say we want to label our species based on whether they are a droid, human or neither of the two. A useful thing with ifelse() is that the third argument can be another ifelse() function! So we can actually chain ifelse() commands like this: ifelse(starwars$species == &quot;Droid&quot;, &quot;Droid&quot;, ifelse(starwars$species == &quot;Human&quot;, &quot;Human&quot;, &quot;Neither human nor droid&quot;)) This is useful, but quickly becomes convoluted. Imagine how the code would look if we threw in a third and fourth category there! In cases like this, remember to use linebreaks to make the code more readable. You can have a linebreak anywhere after starting a function, and R will still understand that its part of the same function. A suggestion for better formatting than above: ifelse( starwars$species == &quot;Droid&quot;, &quot;Droid&quot;, ifelse( starwars$species == &quot;Human&quot;, &quot;Human&quot;, &quot;Neither human nor droid&quot; ) ) Still, if you have more than, say, four-five categories, this becomes difficult to read and time-consuming. For e.g. adding more information to a data frame, joining may be a better alternative, which we will go through next. 10.2.2 Joining For this section we will revisit the copepods.txt data that we encountered way back in week 2. Start by reading in this data. You should know enough by now to do this by yourself, so we wont show you how. copepods #&gt; depth acartia calanus harpacticoida oithona oncaea temora #&gt; 1 0 0 3 0 2 0 0 #&gt; 2 2 1 0 0 6 1 0 #&gt; 3 4 1 0 0 7 0 1 #&gt; 4 6 27 0 1 0 0 2 #&gt; 5 8 11 0 2 6 0 3 #&gt; 6 10 17 0 3 0 0 2 #&gt; 7 12 13 0 1 0 0 1 #&gt; 8 14 7 0 13 0 0 0 #&gt; 9 16 6 0 6 0 0 1 Next, we use pivot_longer() to get all taxa in a single column, i.e., convert to long format. See if you manage to do this yourself before looking at my code below. copepods_long &lt;- pivot_longer(copepods, -depth, names_to = &quot;taxon&quot;, values_to = &quot;count&quot;) copepods_long #&gt; # A tibble: 54 x 3 #&gt; depth taxon count #&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 0 acartia 0 #&gt; 2 0 calanus 3 #&gt; 3 0 harpacticoida 0 #&gt; 4 0 oithona 2 #&gt; 5 0 oncaea 0 #&gt; 6 0 temora 0 #&gt; 7 2 acartia 1 #&gt; 8 2 calanus 0 #&gt; 9 2 harpacticoida 0 #&gt; 10 2 oithona 6 #&gt; # ... with 44 more rows Now, say that you have recorded the temperature at each depth, and want to add that information to your copepod data. How would you go about doing that? First, here is the data in a data frame: temps &lt;- data.frame( depth = c(0,2,4,6,8,10,12,14,16), temp = c(15.5, 15.4, 15.2, 14.7, 11.4, 8.3, 7.6, 7.0, 6.8) ) temps #&gt; depth temp #&gt; 1 0 15.5 #&gt; 2 2 15.4 #&gt; 3 4 15.2 #&gt; 4 6 14.7 #&gt; 5 8 11.4 #&gt; 6 10 8.3 #&gt; 7 12 7.6 #&gt; 8 14 7.0 #&gt; 9 16 6.8 One way would be using nested ifelse() functions, like we learned in the previous section. This is a lot of work and doesnt look good, but its written it out below just to show you its possible: copepods_long$depthtemp &lt;- ifelse( copepods_long$depth == 0, 15.5, ifelse( copepods_long$depth == 2, 15.4, ifelse( copepods_long$depth == 4, 15.2, ifelse( copepods_long$depth == 6, 14.7, ifelse( copepods_long$depth == 8, 11.4, ifelse( copepods_long$depth == 10, 8.3, ifelse( copepods_long$depth == 12, 7.6, ifelse( copepods_long$depth == 14, 7.0, ifelse( copepods_long$depth == 16, 6.8, NA ) ) ) ) ) ) ) ) ) Instead, you can use the left_join() function from dplyr. You have to supply it the original data, the data you want to join with, and a vector of column names to join by (here depth). copepods_temp &lt;- left_join(copepods_long, temps, by = &quot;depth&quot;) copepods_temp #&gt; # A tibble: 54 x 5 #&gt; depth taxon count depthtemp temp #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 acartia 0 15.5 15.5 #&gt; 2 0 calanus 3 15.5 15.5 #&gt; 3 0 harpacticoida 0 15.5 15.5 #&gt; 4 0 oithona 2 15.5 15.5 #&gt; 5 0 oncaea 0 15.5 15.5 #&gt; 6 0 temora 0 15.5 15.5 #&gt; 7 2 acartia 1 15.4 15.4 #&gt; 8 2 calanus 0 15.4 15.4 #&gt; 9 2 harpacticoida 0 15.4 15.4 #&gt; 10 2 oithona 6 15.4 15.4 #&gt; # ... with 44 more rows left_join() matches one or more columns in your two data sets, and add rows from the second data set into the first data set in the correct place. You see that the temp column is equal to the depthtemp we created earlier, but its so much easier to work with! Keep in mind that it is this simple in our case because depth has the exact same name in both data frames. Remember this when recording data in the future! Important concept: If you have your data spread out over multiple files, remember to name columns appropriately. All columns that contain the same kind of data should have the exact same name across all data sets. Similarly, the data should be entered in the same way in both data sets (e.g., dont record depth as 2 in one data set and 2m in the other). If you do this, you can easily join data sets with the left_join() function. "],["lists.html", "10.3 Lists", " 10.3 Lists In this course, we have stored large amounts of data in two types of objects: vectors and data frames. These have some inherent limitations: A vector can only contain one type of value. This means, for example, that one vector cant contain both numeric values AND character values. In a data frame, all columns need to be of the same length. In addition, a column can only contain a single type of value. A list in R, on the other hand, has none of these limitations. It can contain values of multiple types and different lengths. This makes it ideal for storing more complex objects. In fact, much of the complex data you have encountered in these tutorials, like the phylogenetic trees last week, are based on lists. You can make a list with the list() function: my_list &lt;- list(names = c(&quot;Ask&quot;, &quot;Embla&quot;), numbers = c(11, 15, 6, 8), condition = TRUE) my_list #&gt; $names #&gt; [1] &quot;Ask&quot; &quot;Embla&quot; #&gt; #&gt; $numbers #&gt; [1] 11 15 6 8 #&gt; #&gt; $condition #&gt; [1] TRUE You can access list elements with $, or with double square brackets [[]]: # access list element 1 my_list$names #&gt; [1] &quot;Ask&quot; &quot;Embla&quot; my_list[[1]] #&gt; [1] &quot;Ask&quot; &quot;Embla&quot; You can access elements within the vector within the list by adding a second set of (single) square brackets. # access element 1 of the vector in list element 1 my_list[[1]][1] #&gt; [1] &quot;Ask&quot; Since a list can contain any type of data (even data frames and other lists), there are times when they are very useful. We wont go into much more detail about lists here, but it is important that you know that this structure exists and a bit about how to work with them. "],["vectorisation2.html", "10.4 Vectorisation", " 10.4 Vectorisation During the tutorials in this course, you have encountered the term vectorisation a few times(e.g. chapter 5). In short, this is the concept of using functions and doing operations on a vector of values, in contrast to looping over each value and calculating each time. In many cases, it can make calculations faster and more readable. Just to remind you, here is the example we used in chapter 5: # define function to calculate volume of a cylinder cyl_vol &lt;- function(r, h){ return(pi * r^2 * h) } # use the function on single values r &lt;- 3 h &lt;- 8 cyl_vol(r, h) #&gt; [1] 226.1947 # use the function on vectors of values r &lt;- 10:1 h &lt;- 1:10 cyl_vol(r, h) #&gt; [1] 314.15927 508.93801 603.18579 615.75216 565.48668 471.23890 351.85838 #&gt; [8] 226.19467 113.09734 31.41593 An equivalent for-loop to the last example would be: # create empty vector vols &lt;- rep(NA, length(r)) # do calculations in loop for (i in 1:length(r)){ vols[i] &lt;- cyl_vol(r[i], h[i]) } vols #&gt; [1] 314.15927 508.93801 603.18579 615.75216 565.48668 471.23890 351.85838 #&gt; [8] 226.19467 113.09734 31.41593 Notice how much simpler the vectorised solution looks. For simple operations like these, vectorising instead of looping is a no-brainer. Now, we will look at some more ways to vectorise, with the sapply() and lapply() functions. 10.4.1 Using lapply() to vectorise In chapter 5, you learned about the apply() function, for applying a function to a data frame or matrix. The lapply() function work similarly, but on vectors and lists instead. Say you have a simple function that takes a vector as input, and rescales each element to the proportion of the total by dividing on the sum of the vector. In other words, calculate and return \\(\\frac{x}{sum(x)}\\). Exercise: Make a function that does the above, and test it with a couple of different vectors. # define function calc_proportion &lt;- function(x){ return(x/sum(x)) } # test it calc_proportion(c(1, 3, 6)) #&gt; [1] 0.1 0.3 0.6 calc_proportion(c(17, 36, 24, 55)) #&gt; [1] 0.1287879 0.2727273 0.1818182 0.4166667 Now, what if we want to do this with several vectors? We may for example have a list of vectors, and want to apply this function to all of them: numbers_list &lt;- list( c(1, 3, 6), c(17, 36, 24, 55), c(100, 500, 400, 38, 75) ) numbers_list #&gt; [[1]] #&gt; [1] 1 3 6 #&gt; #&gt; [[2]] #&gt; [1] 17 36 24 55 #&gt; #&gt; [[3]] #&gt; [1] 100 500 400 38 75 If we simply try to use the function on the list directly, we get an error. R has no way of using sum() on a list! calc_proportion(numbers_list) #&gt; Error in sum(x): invalid &#39;type&#39; (list) of argument This is where lapply() comes in. lapply() (or list apply) takes a list or vector as input, and applies a function to each element of the list/vector. The syntax is lapply(list, function). Like with apply(), the function should not have parentheses after its name. Lets use this to apply calc_proportion() to numbers_list: lapply(numbers_list, calc_proportion) #&gt; [[1]] #&gt; [1] 0.1 0.3 0.6 #&gt; #&gt; [[2]] #&gt; [1] 0.1287879 0.2727273 0.1818182 0.4166667 #&gt; #&gt; [[3]] #&gt; [1] 0.08984726 0.44923630 0.35938904 0.03414196 0.06738544 Now we get a list of our rescaled vectors! Note that lapply() always returns a list (hence list apply). Like earlier examples weve seen, it doesnt matter if numbers_list has a single value or a million, the code would still look the same1. Important concept: lapply() allows for fast and simple vectorisation when your function cannot be applied to your data directly. It takes a list/vector and a function as arguments, and returns a list of values. 10.4.2 sapply() sapply() (or simplified apply) is very similar to lapply() in that it takes a list or vector and a function as arguments, and applies the function to the list/vector. The key difference is that where lapply() always returns a list, sapply() returns the simplest possible object. For example, say we want to use sum() on each vector in numbers_list. With lapply() we get: lapply(numbers_list, sum) #&gt; [[1]] #&gt; [1] 10 #&gt; #&gt; [[2]] #&gt; [1] 132 #&gt; #&gt; [[3]] #&gt; [1] 1113 However, each list element only contains one value. Wouldnt it be easier to have it stored in a vector? This is what we get with sapply(): sapply(numbers_list, sum) #&gt; [1] 10 132 1113 Important concept: sapply() can be convenient to simplify the output of a vectorised operation. Use sapply() if you want the simplest data structure possible, and lapply() when you want to be sure that your operation returns a list. 10.4.3 Anonymous functions A concept that is often used together with lapply() and sapply() is anonymous functions. Like the term implies, this is a function without a name. For example, instead of creating the calc_proportion() function above, we could have defined the function inside our lapply() function like this2: lapply(numbers_list, function(x) x/sum(x)) #&gt; [[1]] #&gt; [1] 0.1 0.3 0.6 #&gt; #&gt; [[2]] #&gt; [1] 0.1287879 0.2727273 0.1818182 0.4166667 #&gt; #&gt; [[3]] #&gt; [1] 0.08984726 0.44923630 0.35938904 0.03414196 0.06738544 It works in the exact same way, but you dont have to define a function beforehand, and is easy to understand for the reader right away. Only use this for very simple functions that you are only going to use once. Otherwise, defining a named function is better. It is good to know about anonymous functions anyway, as they are frequently used. Of course, this can also be achieved with a for-loop, which looks like this: # create empty list, confusingly with the vector() function ... proportion_list &lt;- vector(mode = &quot;list&quot;, length = length(numbers_list)) # loop and calculate for (i in 1:length(numbers_list)){ proportion_list[[i]] &lt;- calc_proportion(numbers_list[[i]]) } proportion_list #&gt; [[1]] #&gt; [1] 0.1 0.3 0.6 #&gt; #&gt; [[2]] #&gt; [1] 0.1287879 0.2727273 0.1818182 0.4166667 #&gt; #&gt; [[3]] #&gt; [1] 0.08984726 0.44923630 0.35938904 0.03414196 0.06738544  Note that the function here is defined without the use of curly brackets and return(). This is not unique to anonymous functions (but most often used there), but an equivalent way to define a function in R. This means that all these four functions are exactly equal: f1 &lt;- function(x) x/sum(x) f2 &lt;- function(x) return(x/sum(x)) f3 &lt;- function(x){ x/sum(x) } f4 &lt;- function(x){ return(x/sum(x)) } When the function is more than a single line, you should always use the curly brackets. I personally prefer to use an explicit return() in more complicated functions, but you will encounter both in code you read. "],["concluding-remarks.html", "10.5 Concluding remarks", " 10.5 Concluding remarks We hope the more indepth focus on programming and more advanced use of R in this tutorial has given you more insight into how these aspects of R work. Ultimately, the best way to become familiar and experienced with these methods is to repeatedly use them, often on your own data, to solve your own issues. Programming is a challenge for many people in any language - and it can be especially challenging for biologists. The key thing to keep in mind is that you are now familiar with the basics. You might still feel daunted at the prospect of sitting down and writing a function or set of code completely from scratch. However as you have seen from these tutorials and also those linked at the end of each section, there is a wealth of resources available online that can demystify many of these concepts further. The most important thing for your own future work is that you can grapple with these tutorials and then take things a step further each time. Even for experienced users, it takes time and thought to code in R - we hope that these tutorials have set you on the trajectory to becoming more advanced users! Good luck! "],["study-questions-8.html", "10.6 Study questions", " 10.6 Study questions The study questions for week 10 are found here. Deliver them in Canvas before the deadline as a word or pdf document. See the appendix for some important points on how the assignments should be delivered. There, you will also find an introduction to R Markdown, a good way to combine code, output and text for a report. "],["going-further-9.html", "10.7 Going further", " 10.7 Going further There are many, many resources out there for learning more about programming in R. We have collated a few good ones here: A series of tutorials exploring aspects of R Studio useful for coding Some good examples of control flow in R A short description of control flow, functions and vectorisation in R A more advanced look at why vectorisation is worth pursuing A software carpentry course on creating functions in R "]]
