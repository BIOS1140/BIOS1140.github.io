# Advancing Further in R {#ch10}

```{r html-doc, child="html_doc.Rmd", echo = FALSE}
```

```{r setup, include=FALSE}
source("setup.R")
library(tidyverse)
```



Throughout these tutorials, we have introduced you to evolutionary genetic concepts using R. By now, you should have some familiarity with the versatility of R for data analysis and what is possible with it. We have gone from manipulating vectors and dataframes to processing genome-resequencing data and calculating population genomic statistics. With a course as broad as this, we understand it is difficult to feel like you fully understand every aspect of the analyses you are conducting - there is obviously a lot to learn! Ultimately, it is impossible for you to achieve this within a single course, using R properly takes experience and practice. Indeed, we'd argue that there is no real mastery of R, it is a tool with which you are always able to learn new things. We learn all the time in R and we have been using it for quite some time!

Nonetheless, there are obviously basics that you can master and that you can build upon in your own work, research and analysis. You are already familiar with many of the most important of these - data structures, how to use functions, how to manipulate and visualise data. How can we go further, to giving you an introduction to some more advanced techniques in R? In this final session, will take a step back from population and evolutionary genetics to focus once more on how R itself works, except this time we will focus mainly on programming. We will return to some R programming topics you have actually already encountered but in more detail, with more of a focus on explaining them piece-by-piece.

### What to expect {.unnumbered}

In this section we will:

-   learn about some advanced features of RStudio
-   learn more about the principles of control flow
-   take a refresher in vectorisation with `sapply`
-   return to learning about how to write functions

### Getting started {.unnumbered}

As always, we need to set up our R environment. We'll load `tidyverse` as usual and that's the only package we will use today.

```{r, eval = FALSE, echo = TRUE, results = "hide", message = FALSE, warning = FALSE}
# clear the R environment
rm(list = ls())

# install new packages
install.packages("tidyverse") # if not already installed

# load packages
library(tidyverse)
```

## Advanced features of RStudio

```{r html-doc, child="html_doc.Rmd", echo = FALSE}
```


Back in the [introductory session](https://evolutionarygenetics.github.io/Introduction.html), we learned tht RStudio is a front-end for R. More specifically, RStudio is an **integrated development environment** that makes it more straightforward to do a lot [more than just interact with the console](https://www.rstudio.com/products/rstudio/features/). Much of these features are specifically designed with programming in mind and so we will give a short introduction to them.

### Projects, projects, projects

One of the most useful features of RStudio is it's ability to separate your work into different projects. Throughout the tutorials, you might have amassed a large number of files (i.e. datasets, scripts and so on) with little obvious organisation. You might have also had to set your working directory repeatedly.

This can become very tedious when you are working on multiple things at once in R. Instead, you can very easily subdivide your work into different RStudio projects, which are essentially separate working directories. You can make brand new ones or associate them with existing work.

You can see here for [a more detailed explanation on how to manage projects in RStudio.](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects)

### Everyone has a history

Another useful feature of RStudio (and also the standard R distribution) is the fact that every command, function and input you type to the console is stored as a history. You can access this very easily using the function `history`. For example:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# show recent command history
history()
```

In RStudio, this command will actually open the `history` pane and show you previous commands that you have run. You can even use the buttons at the top of this pane to reread commands into the console (i.e. `To Console`) or copy them into an R script (`To Source`).

There is also an even easier way for you to quickly access the history or previously run commands when you are in the console. You can simply press the `up` key on your keyboard to rerun the previous lines. This can save you a lot of time and retyping.

### Tab complete and other hotkeys

When typing code into a script or the R console, RStudio allows you to do something called **tab completion**. This simply means if you hit the `tab` key while typing a function or object name, it will give you a list of options. For example, try typing `pl` into the R console and then pressing tab. You will see a list of available functions and you can then select the function you want from them.

Tab completion also works within a function too. Try using tab complete to call the function `plot` and then pressing it again inside the brackets. You will see the arguments the function requires and if you hover over them, a small pop-up will give you a brief explanation of what they are.

There are actually a large number of keyboard based shortcuts you can make use of with Rstudio - these include useful things like `Ctrl + 1` or `Ctrl + 2` to switch between the console and script panes. You can see [a whole list of them here](https://support.rstudio.com/hc/en-us/articles/200711853-Keyboard-Shortcuts) or by selecting `Tools > Keyboard Shortcuts Help` from the menu bar at the top of the program.

### Code checking

A further useful feature for writing R scripts is the fact that the script viewer has a code syntax checker. This checks whether arguments or brackets are missing. For example, try pasting the following into a script and seeing what you get:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# Try these to trigger RStudio syntax checking
plot(x, )
result <- c(1,2,3))
```

It might take some time to get used to reading these, but it is very helpful for seeing where errors might have occurred. This is especially useful if you are writing large blocks of code and you want to get some insight into what might be going wrong. Indeed, this is part of RStudio's general design as a coding tool - you will have also noticed some of the other features this incorporates by now like syntax highlighting. For example, have a look at the simple `for` loop code block below, you can clearly see that RStudio highlights different parts of the code.

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# a simple for loop
for (i in 1:10){
  print(i)
}
```

This simple block contains two **control flow** examples (`for` and `in`) - these are highlighted in in the code block here. There is also a numeric vector - this is shown in a different colour. Everything else, including objects and standard function calls are in black. Syntax highlighting like this makes code easier to read and is [highly customisable too](https://support.rstudio.com/hc/en-us/articles/200549016-Customizing-RStudio).

## More on data handling---categorising and relating

Handling large amounts of data with few lines of code is one of R's strong points. In this section we will show how you can use `ifelse()` and the `left_join()` function from dplyr to make categories and add information to your data

### `ifelse()` for making categories

Let's first review what the `ifelse()` function does. As you learned back in [chapter 5](#ifelse), `ifelse()` takes a logical statement, and returns something different depending on whether the condition is `TRUE` or `FALSE`:

```{r, eval = FALSE, echo = TRUE, results = 'hide', message = FALSE}
# make a small vector
y <- c(20, 30, 50)
# use ifelse to evaluate it
ifelse(y > 25, "Greater than 25", "Not greater than 25")
```

This function can be extremely useful for creating new variables in datasets. Let's return to the familiar `starwars` data from `dplyr` in order to use the function in this way.

```{r, eval = TRUE, echo = TRUE, results = 'hidden', message = FALSE}
starwars
```

Now we can take a look at the `starwars$species` vector. There are a lot of different species, so what if we wanted to create a vector that simply states whether an individual is a droid or not?

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# if else to identify droids and non-droids
ifelse(starwars$species == "Droid", "Droid", "Non-Droid")
```

This can be useful e.g. for comparing droids and non-droids in a plot or table. Say we want to label our species based on whether they are a droid, human or neither of the two. A useful thing with `ifelse()` is that the third argument can be _another_ `ifelse()` function! So we can actually chain `ifelse()` commands like this:

```{r}
ifelse(starwars$species == "Droid", "Droid", ifelse(starwars$species == "Human", "Human", "Neither human nor droid"))
```

This is useful, but quickly becomes convoluted. Imagine how the code would look if we threw in a third and fourth category there! In cases like this, remember to use linebreaks to make the code more readable. You can have a linebreak anywhere after starting a function, and R will still understand that it's part of the same function. A suggestion for better formatting than above:

```{r}
ifelse(
  starwars$species == "Droid", "Droid", 
  ifelse(
    starwars$species == "Human", "Human", 
    "Neither human nor droid"
    )
  )
```

Still, if you have more than, say, four-five categories, this becomes difficult to read and time-consuming. For e.g. adding more information to a data frame, _joining_ may be a better alternative, which we will go through next.

### Joining

For this section we will revisit the [copepods.txt](https://BIOS1140.github.io/data/copepods.txt) data that we encountered way back in [week 2](#w02). Start by reading in this data. You should know enough by now to do this by yourself, so we won't show you how.

```{r echo = FALSE}
copepods <- read.table("docs/data/copepods.txt", header = TRUE)
```

```{r}
copepods
```


Next, we use `pivot_longer()` to get all taxa in a single column, i.e., convert to long format. See if you manage to do this yourself before looking at my code below.


:::{.fold .c}
```{r}
copepods_long <- pivot_longer(copepods, 
                              -depth, 
                              names_to = "taxon", 
                              values_to = "count")
```
:::

```{r}
copepods_long
```

Now, say that you have recorded the temperature at each depth, and want to add that information to your copepod data. How would you go about doing that? First, here is the data in a data frame:

```{r}
temps <- data.frame(
  depth = c(0,2,4,6,8,10,12,14,16),
  temp = c(15.5, 15.4, 15.2, 14.7, 11.4, 8.3, 7.6, 7.0, 6.8)
)
temps
```

One way would be using nested `ifelse()` functions, like we learned in the previous section. This is a lot of work and doesn't look good, but it's written it out below just to show you it's possible:

:::{.fold .c}
```{r}
copepods_long$depthtemp <- ifelse(
  copepods_long$depth == 0, 15.5,
  ifelse(
    copepods_long$depth == 2, 15.4,
    ifelse(
      copepods_long$depth == 4, 15.2,
      ifelse(
        copepods_long$depth == 6, 14.7,
        ifelse(
          copepods_long$depth == 8, 11.4,
          ifelse(
            copepods_long$depth == 10, 8.3,
            ifelse(
              copepods_long$depth == 12, 7.6,
              ifelse(
                copepods_long$depth == 14, 7.0,
                ifelse(
                  copepods_long$depth == 16, 6.8,
                  NA
                )
              )
            )
          )
        )
      )
    )
  )
)


```
:::

Instead, you can use the `left_join()` function from `dplyr`. You have to supply it the original data, the data you want to join with, and a vector of column names to join by (here "depth").

```{r}
copepods_temp <- left_join(copepods_long, temps, by = "depth")
copepods_temp
```

You see that the `temp` column is equal to the `depthtemp` we created earlier, but it's so much easier to work with! Keep in mind that it is this simple in our case because `depth` has the exact same name in both data frames. Remember this when recording data in the future!

:::{.green}
**Important concept:**  
If you have your data spread out over multiple files, remember to name columns appropriately. All columns that contain the same kind of data should have the _exact same name_ across all data sets. This makes joining much easier.
:::

## Vectorisation

```{r html-doc, child="html_doc.Rmd", echo = FALSE}
```

During the tutorials in this course, you have encountered the term "vectorisation" a few times(e.g. [chapter 5](#vectorisation)). In short, this is

### Why is vectorisation preferable in R?

You've heard quite a few times now that **vectorisation** is preferable in R to `for` loops. Why exactly is this? Well there are multiple reasons; chief among these is that vectorisation is much (generally) much faster. Another advantage is that it makes code a lot more clear and straightforward.

Let's use a simple example to demonstrate this - we will generate a vector with 80,000 elements in it. We need to make a large vector because the speed differences among different approaches become much clearer when we do so. We will call this vector `large`. First, we'll do this with a `for` loop:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# set up the object
large <- NULL
# now use the for loop
for (i in 1:80000){
  large <- c(large, i)
}
# make sure large is 80,000 elements long
length(large)
```

If you run this code, you'll see it took quite a few seconds to work properly. We can actually measure this but before we do, let's take a moment to look at the `for` loop again. In this example, we first have to declare `large` as a `NULL` object and then we run the loop. Within the loop, we use `large <- c(large, i)` to basically add each value of `i` (so 1, 2, 3 etc) to the `large` vector. In R this is a long-winded way to **append** to a vector.

So, why don't we actually measure how long this took?. To do this we can use a nice function called `system.time`.

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# set up the object
large <- NULL
# now use the for loop - wrapped in system.time
system.time(
  for (i in 1:80000){
  large <- c(large, i)
}
)
```

This will vary based on your machine but the important value is `elapsed`. When we ran this, it took 8.1 seconds, which is pretty long. There are much faster ways to achieve the same result. For example, we could use `seq` to create the same thing.

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# create large using seq
large <- seq(1, 80000)
```

How long did that take?

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# create large using seq and measure time
system.time(large <- seq(1, 80000))
```

In our case, it took practically no time at all. We could have even dropped `seq` altogether and just done the following:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# create large
large <- 1:80000
```

Which also doesn't take any time at all.

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# create large
system.time(large <- 1:80000)
```

This is a really clear demonstration of what we mean by vectorisation. When you write R code, you should aim to work with vectors. In the last two examples, we are generating vectors directly, rather than using a for loop to create them. The speed gains are considerable and when you work with very large datasets, they can mean the difference between a few minutes of calculation vs hours.

### Using `sapply` instead of `for` on vectors

So if `for` loops should be avoided, what can you use instead? This is when the `apply` family of functions come into play - i.e. `sapply`, `lapply` and `apply`. We have already used all of these functions in the tutorials, but here we will learn about them again in a bit more detail. First let's show how we could use `sapply` to replace a simple `for` loop. Below we return to our simple `for` loop.

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# a simple for loop
for(i in 1:10){
  print(i)
}
```

We can achieve exactly the same result with `sapply` like so:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# a simple sapply example
sapply(1:10, function(x) x)
```

Let's break down the `sapply` example. It might help if you think of `sapply` as a way of applying a function across a vector. This is similar to how a for loop works - basically for each element of the vector, we do something to it. So in this case, the first argument `1:10` is just the vector we are going to apply our function to. The `function(x)` argument is just saying that we call each element of `1:10` `x` and then after this, we do something to it. Here we just display `x` in the console. We could alter the code so that it adds 100 and then divides by the value of x each time. For example:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# a another sapply example
sapply(1:10, function(x) (x + 100)/x)
```

The point being here that we can write whatever we want after the `function(x)` to get R to do something to each value of the vector. We can make `sapply` even simpler if we decide to use a function instead of some basic code. For example, let's use it to calculate the square root of each value of a vector.

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# a really simple sapply example
sapply(1:10, sqrt)
```

This perhaps makes `sapply` even clearer. We are basically saying, here is a vector (`1:10`) and then apply a function to each element of it (`sqrt` in this case).

These examples nicely dmeonstrate why you might use `sapply` but you should not forget that in many cases, you can apply the factor **directly** to the vector without needing to wrap it in an `sapply` function. For example:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# reducing things even further
sqrt(1:10)
```

This too has obvious speed gains:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
system.time(sapply(1:100000, sqrt))
system.time(sqrt(1:100000))
```

The difference is smaller than when we compared vectorised functions to `for` loops, but it is still enough to make a difference. The point then is clear... you should strive to simplify your code as much as possible!

### Using apply instead of `for` on matrices and dataframes

Earlier we saw an example of how we can use a `for` loop to iterate over a matrix. We'll use a similar example below with the `cars` data.

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# calculate the sums of rows
for(i in 1:nrow(cars)){
  print(sum(cars[i, ]))
}
```

This prints a vector of the row sums. But there are a couple of issues. Firstly, it isn't the most straightforward code ever and secondly, it is actually quite annoying to actually get a vector from our `for` loop. If we wanted to store the vector so we could use it later, we need to declare it like so.

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# declare an empty vector
car_row <- NULL
# calculate the sums of rows and save to a vector
for(i in 1:nrow(cars)){
  car_row <- c(car_row, sum(cars[i, ]))
}
# check the car_row vector
car_row
```

We could however just use `apply` to do this all much more cleanly and simply:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# calculate the sums of rows with apply
apply(cars, 1, sum)
```

This immediately returns a vector and is much more straightforward to write. Like `sapply`, `apply` also applies a function, but this time over a matrix or data.frame. Here we specify the `cars` data.frame as our target and then use `1` to explain that we are applying the function over the **rows**. The function we apply is `sum`.

If we change the index in our `apply` function to `2`, we can apply the function `sum` across the columns:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# calculate the sums of columns with apply
apply(cars, 2, sum)
```

We can easily replace `sum` with a function of our choice - i.e. `mean`, `exp` or whatever you prefer. However as always, we should keep in mind there are R specific functions for achieving row sums and column sums which are faster and even simpler than `apply`:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# R functions to calculate row and column sums
rowSums(cars)
colSums(cars)
```

With these functions in place, you might be left wondering what is the point of `sapply` or `apply`. However, applying functions can come into its own when you use a custom function you have written. In the next section, we will return once again to doing this.

## Returning to writing your own functions

```{r html-doc, child="html_doc.Rmd", echo = FALSE}
```


We already learned a little bit about writing custom functions back in [Chapter 3](https://evolutionarygenetics.github.io/Chapter3.html). We'll spend a bit more time on the topic here to demonstrate again how we can do this simply.

We are going to start with a very easy and simple function which we will call `greeting` that will take the name of a person and then say hello to them. Let's write the function below:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# writing a simple function
greeting <- function(name){
  x <- paste0("Hello ", name, ", how are you today?")
  return(x)
}
# Now test the function
greeting("Arthur")
```

Try it with any name you wish,. This simple example demonstrates how functions work in R. First we use `function()` to actually define the function itself. `greeting <- function(name)` simply means we are creating a function called `greeting` and that it takes a single argument, `name`.

The real work of the function goes on inside the curly brackets. We use `paste0` to join the character variables together, forming a full sentence which we call `x`. We then use the `return` function to actually return the value of `x` from the function itself.

The curly brackets define the scope of the `name` argument all arguments within the function itself. So for example, if you run `greeting`, the value of x in the main R environment will not change.

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# set up x
x <- "I am not a greeting"
# use the greeting function
greeting("Sandra")
# x has not changed
x
```

You really can do whatever you want with your own functions. Let's move on to a more serious example here. Perhaps we want to a function that will take the [reciprocal](https://en.wikipedia.org/wiki/Reciprocal) of each number we give it. There is no R function to do this, so we should write our own.

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# a simple reciprocal example
reciprocal <- function(x){
  # calculate the reciprocal
  y <- 1/x
  return(y)
}
```

Now we have this custom function defined in our R environment. We can test it on various numeric values. For example:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# testing our function
reciprocal(8)
reciprocal(10)
```

We can also use it on vectors by default, so no need for `sapply`:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# testing our function on a vector
reciprocal(1:50)
```

Perhaps though we could use something like `apply` to find the reciprocal of each of the values in the rows of the `cars` data.frame? We could do this without a function like so:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# using apply to find the reciprocal of rows
apply(cars, 1, function(x) 1/x)
```

This actually produces a matrix that gives us the reciprocal of each value in each row. Of course, we can make the code even neater by substituting in the custom function we wrote previously.

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# using apply to apply our reciprocal function
apply(cars, 1, reciprocal)
```

This gives the same result. This code is neater, but it also has the advantage that if we want to troubleshoot any issues or change the code, we only need to alter the function itself, not the `apply` argument. Let's alter our reciprocal function so that it first sums all the values you give it. We'll call it `reciprocal_sum` to distinguish it.

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# a simple reciprocal example
reciprocal_sum <- function(x){
  # calculate the reciprocal
  y <- 1/sum(x)
  return(y)
}
```

With single values it makes no difference, but with vectors it takes the reciprocal of their sum. For example:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# testing our altered function
reciprocal_sum(8)
reciprocal_sum(10)
reciprocal_sum(1:50)
```

So now, if we want to take the reciprocal of the sum of each row using apply, we can do it like this:

```{r, eval = FALSE, echo = TRUE, results = 'hidden', message = FALSE}
# using apply to apply our reciprocal function
apply(cars, 1, reciprocal_sum)
```

Where all we did is alter the original function (and tweaked our apply command to make sure it ran the right one). This shows you that can easily build on the complexity of a function and also combine it with other functions such as `apply` to do quite a lot with your data.

## Concluding remarks

We hope the more indepth focus on programming and more advanced use of R in this tutorial has given you more insight into how these aspects of R work. Ultimately, the best way to become very familiar and experienced with these methods is to repeatedly use them, often on your own data, to solve your own issues. Programming is a challenge for many people in any language - and it can be especially challenging for biologists. The key thing to keep in mind is that you are now familiar with the basics. You might still feel daunted at the prospect of sitting down and writing a function or set of code completely from scratch. However as you have seen from these tutorials and also those linked at the end of each section, there is a wealth of resources available online that can demystify many of these concepts further. The most important thing for your own future work is that you can grapple with these tutorials and then take things a step further each time. Even for experienced users, it takes time and thought to code in R - we hope that these tutorials have set you on the trajectory to becoming more advanced users!

Good luck!

## Study questions

The study questions for week 10 are found [here](#w10). Deliver them in Canvas before the deadline as a word or pdf document. A good way to combine code, output and text is by using RMarkdown, see [the appendix](#rmarkdown).

## Going further

There are many, many resources out there for learning more about programming in R. We have collated a few good ones here:

-   [A series of tutorials exploring aspects of R Studio useful for coding](https://www.rstudio.com/online-learning/)
-   [Some good examples of control flow in R](http://resbaz.github.io/2014-r-materials/lessons/30-control-flow/)
-   [A short description of control flow, functions and vectorisation in R](https://ramnathv.github.io/pycon2014-r/learn/controls.html)
-   [A more advanced look at why vectorisation is worth pursuing](http://www.noamross.net/blog/2014/4/16/vectorization-in-r--why.html)
-   [A software carpentry course on creating functions in R](https://swcarpentry.github.io/r-novice-inflammation/02-func-R/)
